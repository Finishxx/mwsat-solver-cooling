@startuml

' ===================== Config =====================

class EvaluatedWSatConfig {
  + MaxWSatInstance(const &MaxWSatInstance)
  + instance: MaxWSatInstance*
  + configuration: SatConfig
  + weight: uint32_t
  + isSatisfied: boolean
  + satisfiedCount: uint32_t
}
EvaluatedWSatConfig *-- SatConfig

class SatConfig <<Struct>> {
  + instance: MaxWSatInstance*
  + underlying: vector<bool>
}

' ===================== Solver =====================

class MaxWSatSolver {
  - variables: vector<LiveVariable>
  - clauses: vector<LiveClause>
  + MaxWSatSolver(instance: MaxWSatInstance, initial: SatConfig)
  + evaluatedState(): const &EvaluatedWSatConfig
  + exportConfig(): EvaluatedWSatConfig
  + instance(): const &MaxWSatInstance
  + flipVariable(variable: uint32_t)
  + setConfig(config: SatConfig&): void
}
MaxWSatSolver "1" o-- MaxWSatInstance
MaxWSatSolver "1" *-- EvaluatedWSatConfig
MaxWSatSolver "1..N" *-- LiveClause
MaxWSatSolver "1..N" *-- LiveVariable
note left of MaxWSatSolver::"variables: vector<LiveVariable>"
  Variable's id represents
  index into this
end note
note left of MaxWSatSolver::"evaluatedState(): const &EvaluatedWSatConfig"
  Is mutated on every variable flip
end note
note left of MaxWSatSolver::"exportConfig(): EvaluatedWSatConfig"
  Creates an independent copy
end note


' ===================== Live Data =====================

class LiveClause {
  - satisfiedCount: uint32_t
  - terms: vector<LiveTerm>
  + getTerm(uint32_t id): const LiveTerm *
  -- Mutations --
  + setVariable(uint32_t id): void
  + unsetVariable(uint32_t) id): void
  + flipVariable(uint32_t id): void
}
LiveClause "1..N" --> LiveTerm
note bottom of LiveClause
  Maybe give and id too?
end note

class LiveVariable {
  + original: Variable*
  + occurrences: vector<LiveClause*>
  + weight(): uint32_t
  + id(): uint32_t
}
LiveVariable "1..N" --> LiveClause

class LiveTerm {
  + isSet(): bool
  + originalTerm(): const Term&
  + id(): uint32_t
  + isSatisfied(): bool
  + isSet(): bool
  + LiveTerm(Term original, bool isSet)
  -- Mutations --
  + set(): void
  + unset(): void
  + flip(): void
}
note bottom of LiveTerm
  Maybe give an id too?
end note

' ===================== Instance =====================

class MaxWSatInstance {
  + MaxWSatInstance(vector<vector<int32_t>> clauses, vector<int32_t> weights)
  + clauses(): const &vector<Clause>
  + variables(): const &vector<Variable>
  + isSatisfiable(): bool
}
MaxWSatInstance "1..N" *-- Clause
MaxWSatInstance "1..N" *-- Variable
note left of MaxWSatInstance::"clauses: vector<Clause>"
  Throws in constructor
  if any class is unsatisfiable
end note

class Clause {
  + disjuncts: vector<Term>
  + isSatisfiable: boolean
  + containsVariable(uint32_t id): bool
}
note right of Clause::"disjuncts: vector<Term>"
  Unique and sorted
end note

Clause "1..N" *-- Term
class Term {
  - underlying: int32_t
  + id(): uint32_t
  + isNegated(): boolean
  + isPlain(): boolean
}
note left of Term::"id: uint32_t"
  <color:green>return</color> abs(underlying)
end note

note left of Term::"isNegated(): boolean"
  <color:green>return</color> underlying < 0
end note

note left of Term::"isPlain(): boolean"
  <color:green>return</color> underlying > 0
end note

class Variable {
  + id: uint32_t
  + weight: int32_t
  + occurrences: vector<Clause>
}
Variable "1..N" *- Clause

@enduml